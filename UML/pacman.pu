@startuml pacman

skinparam Shadowing false
skinparam classAttributeIconSize 0

GameObject <|-- Character
GameObject <|-- Item
Character <|-- Pacman
InputInterface <|.. KeyboardInput
InputInterface <|.. ArcadeInput
Character <|-- Monster
Monster <|-- Akabei
Monster <|-- Pinky
Monster <|-- Aosuke
Monster <|-- Guzuta
Stage o-- Pacman
Stage o-- Monster
Stage o-- Map
Stage o-- InputInterface
Map o-- Item
Map o-- MapObject

abstract class GameObject {
    # position: PVector
    # size: PVector

    # GameObject(position: PVector, size: PVector): 
    + getPosition(): PVector
    + getMinPosition(): PVector
    + getMaxPosition(): PVector
    + {abstract} draw
}

abstract class Character {
    # direction: int
    # speed: float

    # images: PImage[][]
    # characterName: String
    # curAnimation: int
    # animetionNum: int
    # interval: int
    # intervalLeft: int

    # Character(position: PVector, direction: int, speed: float, characterName: String, interval: int)
    + getDirection(): int
    + getSpeed(): int
    + setSpeed(speed: float)
    # getDirectionVector(int direction)
    + move(map: Map)
    + canMove(map: Map, direction: int): boolean
    + draw()
}

class Pacman {
    # invincible: boolean
    # nextDirection: int

    + Pacman(position: PVector, direction: int, speed: float, characterName: String, interval: int)
    + getNextDirection(): int
    + setNextDirection(nextDirection: int)
    + getInvincible(): boolen
    + setInvincible(invincible: boolean)
    + decideDirection(map: Map)
}

abstract class Monster {
    # ijike: boolean

    # Monster(position: PVector, direction: int, speed: float, characterName: String, interval: int)
    + getIjike(): boolen
    + setIjike(ijike: boolean)
    + {abstract} decideDirection(map: Map, pacman: Pacman)
}

class Akabei {
    + Akabei(position: PVector, direction: int, speed: float, characterName: String, interval: int)
    + decideDirection(map: Map, pacman: Pacman)
}

class Pinky {
    + Pinky(position: PVector, direction: int, speed: float, characterName: String, interval: int)
    + decideDirection(map: Map, pacman: Pacman)
}

class Aosuke {
    + Aosuke(position: PVector, direction: int, speed: float, characterName: String, interval: int)
    + decideDirection(map: Map, pacman: Pacman)
}

class Guzuta {
    + Guzuta(position: PVector, direction: int, speed: float, characterName: String, interval: int)
    + decideDirection(map: Map, pacman: Pacman)
}

class Stage {
    # pacman: Pacman
    # monsters: ArrayList<Monster>
    # map: Map
    # input: InputInterface
    # stageName: String

    + Stage(stageName: String, input: InputInterface)
    + isColliding(object1: GameObject, object2: GameObject): boolean
    + update()
    + draw()
}

class Map {
    # objects: MapObject[][]
    # foods: ArrayList<Item>
    # powerFoods: ArrayList<Item>
    # pacmanPosition: PVector
    # enemyPositions: ArrayList<PVector>
    # stageName: String
    # image: PImage
    # size: PVector

    + Map(stageName: String)
    + getObject(x: int, y: int): MapObject
    + draw()
}

class Item {
    # exist: boolean
    # imageName: String
    # image: PImage

    + Item(position: PVector, imageName: String)
    + getExist(): boolean
    + disappear()
    + draw()
}

enum MapObject {
    Wall
    Route
    EnemyBase
    EnemyDoor
}

interface InputInterface {
    + {abstract} right(): boolean
    + {abstract} up(): boolean
    + {abstract} left(): boolean
    + {abstract} down(): boolean
    + {abstract} buttonA(): boolean
    + {abstract} buttonB(): boolean
}

class KeyboardInput {
    + right(): boolean
    + up(): boolean
    + left(): boolean
    + down(): boolean
    + buttonA(): boolean
    + buttonB(): boolean
}

class ArcadeInput {
    + right(): boolean
    + up(): boolean
    + left(): boolean
    + down(): boolean
    + buttonA(): boolean
    + buttonB(): boolean
}

@enduml
